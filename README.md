# C语言

## 进制转换
自己看，高中学过。


说在前面：计算机计数从 ```0``` 开始 

## 内存单位换算 
- 1Byte = 8 Bit
- 1KB = 1024Byte
- 1MB = 1024KB 
- 1GB = 1024MB
- 1TB = 1024GB
- 1PB = 1024TB
  
## ASCII编码
对应书后的码表，常见的要背下来，比如说 'A' 转换为 'a' 需要做什么操作。

```
char a = 'a';
printf("%c\n", a - 32); //试试输出什么 
```

## 数据类型
- 基本的数据类型对应的数据长度要记住。C语言中比较坑的是```long```这个类型。在某些场景下用int编译可以通过，运行却会出错，考虑是不是数据太大(多数使用long即可)

- ```sizeof```操作符
  
  获取某个数据类型的长度，与后续的strlen需要严格区分。strlen判断的唯一标准是'\0'，它会根据a和b的指针看是一直向后找，直到碰到'\0'，无论是不是自己字符串的结束标志'\0'
    ```
    char *c = "abcdef";
    char d[] = "abcdef";
    char e[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
    printf("%llu %llu\n", sizeof(c), strlen(c)); // 8 6
    printf("%llu %llu\n", sizeof(d), strlen(d)); // 7 6
    printf("%llu %llu\n", sizeof(e), strlen(e)); // 7 7 这个例子可以以后学到字符串和指针的时候再看
    ```

- unsigned
    ```
    unsigned int a = -1; // a本不应该有符号
    printf("%u\n", a); //4294967295
    printf("%d", a); //-1
    ```
    unsigned也是比较坑的地方,printf函数不会管你输出的是什么类型，只与%后面的类型有关，时刻记住```short int long``` 以补码形式存储。输出与其不符的格式时，需要按内存中实际存储的形式来输出。

    再次强调，不管是以 %o、%u、%x 输出有符号数，还是以 %d 输出无符号数，编译器都不会报错，只是对内存的解释不同了。%o、%d、%u、%x 这些格式控制符不会关心数字在定义时到底是有符号的还是无符号的。有符号数也可以按照无符号数输出，无符号数也可以按照有符号数输出，至于输出结果对不对，那我就不管了，你自己承担风险。

    - 你让我输出无符号数，那我在读取内存时就不区分符号位和数值位了，我会把所有的内存都看做数值位；
    
    - 你让我输出有符号数，那我在读取内存时会把最高位作为符号位，把剩下的内存作为数值位。
- float double
  
  将小数类型赋给整数类型会导致失真，也就是丢失精度，并且默认情况下不会四舍五入。编译器一般会给出警告。

- char
  
  char类型的定义要用单引号，为字符型。字符串类型要用双引号。但是带有char的不一定就是字符类型。比如 ```char a[] = "abc"```

## 运算

- 除法 
  
  其他的都比较简单，除法是最为特殊的。但仍然遵守一点数学规则：除数不能为0。
  - 当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。
  - 一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。

- 取余
  
  C语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。
  - 如果 % 左边是正数，那么余数也是正数；
  - 如果 % 左边是负数，那么余数也是负数。

- 自增自减
  - 自增
    - 前置自增
  
      先变量+1，再赋值或做其他操作
    - 后置自增
  
      先赋值或做其他操作，再变量+1
  
  - 自减（同理）
- 运算符优先级
  
  优先级就看书背就行，实际编程时都是用括号决定顺序。```( )```的优先级高于```/```，对于表达式```(double) sum / count```，会先执行```(double) sum```，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作```(double) (sum / count)```，不能保留小数部分。

- 类型转换
  
  在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。强制类型转换并不会改变原变量值。

## 输入输出

- 输入
  
  ```
  int a = 1, b = 2;
  scanf("a=%d", &a);
  fflush(stdin); // 清空标准输入流的缓冲区
  scanf("b=%d", &b);
  printf("%d, %d\n", a, b);
  return 0;
  ```

  ```
  int a = 1, b = 2;
  scanf("a=%d", &a);
  //fflush(stdin);
  scanf("b=%d", &b);
  printf("%d, %d\n", a, b);
  return 0; // 试试这两段代码的区别。体验输出缓冲区。
  ```

  这个可以先作为了解，考试可能不一定会考。

- 输出

  输出这东西，看书，没啥好说的。

## 循环结构和选择结构

- 条件语句
  
  if-else 是最常看见的语句，和高中时的if-else没有任何区别。可以多层嵌套。在C语言里有比较特殊的一点：**0可以代表false**，**非0可以代表true**。

- 关系运算符

  关系运算符的运算结果只有 **0** 或 **1**。当条件**成立**时结果为 1，条件**不成立**结果为 0。

- 逻辑运算符

  逻辑运算符的运算结果只有 **0** 或 **1**。当条件**成立**时结果为 1，条件**不成立**结果为 0。

- switch

  自己看，没难度。只有一点，对于多分支，如果有一个语句后没有带**break**，那么会紧接着执行下一条语句，而**不是**直接退出，不要惯性思维！

- 条件运算符

  ```
  max = (a>b) ? a : b; //该语句的语义是：如a>b为真，则把a赋予max，否则把b 赋予max。
  ```
  条件运算符完全等价于一个if-else语句

- **循环语句**

  循环是出题的重点，主要是在循环的**次数**上会大做文章。务必理解三种循环的流程控制语句。其次就是在循环的嵌套上，对初学者难度比较高。不要慌，问题一般都是出在边界上。这种题务必认真！！！！！！！

  for循环的形式较为灵活，三个表达式都是可写可不写，但是分号不可省略！但是省略了“**表达式2(循环条件)**”，如果不做其它处理就会成为死循环。

  - break语句

    当 break 关键字用于 while、for 循环时，会终止循环而执行整个循环语句后面的代码。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。**在多层循环中，一个 break 语句只向外跳一层。**。break 关键字还可以用于跳出 switch...case 语句。所谓“跳出”，是指一旦遇到 break，就不再执行 switch 中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个 switch 执行结束了，接着会执行整个 switch 后面的代码。

  - continue语句

    continue 语句的作用是跳过循环体中剩余的语句而强制进入下一次循环。continue语句只用在 while、for 循环中，常与 if 条件语句一起使用，判断条件是否成立。

  - 对比

    break与continue的对比：break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。

对于循环嵌套，最低的要求是可以写出九九乘法表的C语言程序。你可以自己试一下。