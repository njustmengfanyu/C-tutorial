# C语言

## 进制转换
自己看，高中学过。


说在前面：计算机计数从 ```0``` 开始 

## 内存单位换算 
- 1Byte = 8 Bit
- 1KB = 1024Byte
- 1MB = 1024KB 
- 1GB = 1024MB
- 1TB = 1024GB
- 1PB = 1024TB
  
## ASCII编码
对应书后的码表，常见的要背下来，比如说 'A' 转换为 'a' 需要做什么操作。

```
char a = 'a';
printf("%c\n", a - 32); //试试输出什么 
```

## 数据类型
- 基本的数据类型对应的数据长度要记住。C语言中比较坑的是```long```这个类型。在某些场景下用int编译可以通过，运行却会出错，考虑是不是数据太大(多数使用long即可)

- ```sizeof```操作符
  
  获取某个数据类型的长度，与后续的strlen需要严格区分。strlen判断的唯一标准是'\0'，它会根据a和b的指针看是一直向后找，直到碰到'\0'，无论是不是自己字符串的结束标志'\0'
    ```
    char *c = "abcdef";
    char d[] = "abcdef";
    char e[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
    printf("%llu %llu\n", sizeof(c), strlen(c)); // 8 6
    printf("%llu %llu\n", sizeof(d), strlen(d)); // 7 6
    printf("%llu %llu\n", sizeof(e), strlen(e)); // 7 7 这个例子可以以后学到字符串和指针的时候再看
    ```

- unsigned
    ```
    unsigned int a = -1; // a本不应该有符号
    printf("%u\n", a); //4294967295
    printf("%d", a); //-1
    ```
    unsigned也是比较坑的地方,printf函数不会管你输出的是什么类型，只与%后面的类型有关，时刻记住```short int long``` 以补码形式存储。输出与其不符的格式时，需要按内存中实际存储的形式来输出。

    再次强调，不管是以 %o、%u、%x 输出有符号数，还是以 %d 输出无符号数，编译器都不会报错，只是对内存的解释不同了。%o、%d、%u、%x 这些格式控制符不会关心数字在定义时到底是有符号的还是无符号的。有符号数也可以按照无符号数输出，无符号数也可以按照有符号数输出，至于输出结果对不对，那我就不管了，你自己承担风险。

    - 你让我输出无符号数，那我在读取内存时就不区分符号位和数值位了，我会把所有的内存都看做数值位；
    
    - 你让我输出有符号数，那我在读取内存时会把最高位作为符号位，把剩下的内存作为数值位。
- float double
  
  将小数类型赋给整数类型会导致失真，也就是丢失精度，并且默认情况下不会四舍五入。编译器一般会给出警告。

- char
  
  char类型的定义要用单引号，为字符型。字符串类型要用双引号。但是带有char的不一定就是字符类型。比如 ```char a[] = "abc"```

## 运算

- 除法 
  
  其他的都比较简单，除法是最为特殊的。但仍然遵守一点数学规则：除数不能为0。
  - 当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。
  - 一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。

- 取余
  
  C语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。
  - 如果 % 左边是正数，那么余数也是正数；
  - 如果 % 左边是负数，那么余数也是负数。

- 自增自减
  - 自增
  
  
  - 自减